
epRISC architecture specification v5, r0

(c) 2015-2016 John C. Lemme - jclemme (at) proportionallabs (dot) com
This file, and the ISA documented within, are released under the epRISC license. See "license.txt" and "license-eprisc.txt" for details.

-------------------------

Registers

The CPU supports up to 224 32-bit registers, split into fourteen pages of sixteen registers each.
The last two register pages, pages hE and hF, are virtual; they exist to access system control registers.

The currently selected register page is mapped with the letters W, X, Y, and Z:

   w        x        y        z
W Ww (IP)  Wx (SP)  Wy (CS)  Wz (GL)
X Xw       Xx       Xy       Xz
Y Yw       Yx       Yy       Yz
Z Zw       Zx       Zy       Zz

Registers Ww, Wx, Wy, and Wz are special; they are mapped to system registers IP, SP, CS, and GL.

IP  Instruction Pointer     Current location of execution
SP  Stack Pointer           Current location of the top of the stack
CS  Core Status             Core status and control flags 
GL  Global Register         Maintains state throughout page changes

The SP register is used to implement the CPU's stack. The stack grows up; pushed values increase the stack pointer and popped values decrease the stack pointer.
When used as the base address register of a load or store instruction, the SP register will automatically adjust to implement a push or pop.

The flags and fields of the CS register control CPU behavior.
Modified flags or fields take effect after the execution of the current instruction.

3                 1 1                 0
1                 6 5                 0
nnnn nnnn nnnn nnnn nnnn nnnn nnnn nnnn     32-bit word 
                m                           Critical Interrupts flag                When true, will always allow critical interrupts to be called.
                 rr                         Interrupt Priority field                Current allowed interrupt priority.
                    pppp                    Register Page field                     Sets the current register page.
                         llll               Global Link Register field              Sets the link register for branch instructions.
                              s             Hide Special Registers flag             When true, allows use of registers Ww through Wz as general purpose registers.
                               w            Wide Handlers flag                      When true, enables wide interrupt handlers. See below.
                                x           ALU Sign Extension flag                 When true, performs sign extension on the value field of arithmetic instructions.
                                 f          Inhibit Flag Set flag                   When true, prevents instructions setting the carry, zero, negative, and overflow flags.
                                   cznv     Carry/Zero/Negative/Overflow flags      Flags set as the result of arithmetic instructions.

A number of race conditions can occur through accidental modification of the "Register Page" field and the "Hide Special Registers" flag of the CS register. 
Because of this, it is recommended to use the "Set Register Page" core instruction to alter these fields.

-------------------------

Memory Access

As a RISC ISA, epRISC performs a maximum of one memory access per instruction. Only the load, store, and branch instructions access memory.
Low priority, medium priority, and software interrupts store their return address on the stack, and perform a memory access doing so.

-------------------------

Reset

Instruction execution begins at h00000000, the first location in memory.
All system registers (IP, SP, CS, and GL) are set to zero after reset. The reset value of all other registers is undefined.

-------------------------

Interrupts

Interrupts are split into four priority levels - low, medium, high, and critical.

The handler address called on an interrupt is created by adding the priority of the interrupt (zero through three) to the handler base address.
Software interrupts have their eight-bit interrupt ID added to the handler base address in the same way; because of this, software interrupts zero through three correspond to hardware interrupts low through critical.

Low priority, medium priority, and software interrupts store their return address on the stack. 
High and critical priority interrupts store their return address in their respective link registers, to avoid a memory access.

The interrupt control system utilizes four control registers, mapped to Xw through Xz of register page hF.

HB  Handler Base            Base address for interrupt handlers.
PS  Priority Stack          Single-word stack used to store pushed priority settings. 
LH  Link High               Link register for high priority interrupt calls.
LC  Link Critical           Link register for critical priority interrupt calls.

The handler base address has two modes, controlled by the "Wide handlers" flag of the CS register.
When wide handlers are disabled, the address called when an interrupt is called will equal the interrupt priority or ID plus the base address.
When wide handlers are enabled, hardware interrupt priorities are multiplied by 32. This leaves a 32-word space for each interrupt priority in the interrupt table for implementation of interrupt handlers. 
This space allows removing the second jump to an interrupt handler, speeding up interrupt service.

The priority stack allows correct priority restoration when returning from an interrupt. 
When an interrupt is called, the current priority setting is pushed to the rightmost side of the stack word, left shifting the rest of the word in the process.
The current priority setting is then replaced with the one that blocks the level of the interrupt called.
When returning from an interrupt, the last pushed priority setting is popped from the same side and replaces the current priority setting, and the rest of the word is right shifted.

Interrupt priorities control which interrupts are blocked, rather than which are allowed, in an "equal or greater" fashion.
The "Force Critical Interrupts" flag of the CS register prevents blocking of critical interrupts. 
 
b00     Block Low                   Block low, medium, high, and critical priority interrupts.
b01     Block Medium                Block medium, high, and critical priority interrupts.
b10     Block High                  Block high and critical priority interrupts.
b11     Block Critical              Block critical priority interrupts.

Branch instructions are used to return from interrupts. These returns will automatically restore the previous priority setting and load the return address from the correct source.

-------------------------

Instruction Set

Instruction words are broken up into six categories. The fields for each instruction category are listed below.
Generally, instructions will take some combination of single-bit flags, four-bit register IDs, and multi-bit values.
Fields labeled with "Reserved and unused" should be set to zero. Instruction behavior with non-zero values in these fields is undefined.


Branch instructions control program flow. They can take a condition code to create a conditional branch.

3                 1 1                 0
1                 6 5                 0
nnnn nnnn nnnn nnnn nnnn nnnn nnnn nnnn     32-bit word  
b                                           Branch select (implied 1)               Flag identifying the instruction as a branch instruction.
 aaa                                        Type code                               Identifies the type of branch to be performed. See below.
     cccc                                   Condition code                          Controls conditional branching. See below.
          rrrr                              Base address register                   Register containing the base address for the branch.
                ooo oooo oooo oooo oooo     Offset (20-bit, +-512kW)                Offset applied to the address in the base address register.


Load/store instructions manipulate values in memory, loading them into or storing them from the CPU's registers.

3                 1 1                 0
1                 6 5                 0
nnnn nnnn nnnn nnnn nnnn nnnn nnnn nnnn     32-bit word  
b                                           Branch select (implied 0)               Set to zero.
 l                                          Load select (implied 1)                 Flag identifying the instruction as a load/store instruction.
  d                                         Direction select                        When true, performs a store operation as opposed to a load operation.
   i                                        Reserved and unused                     Set to zero.
     rrrr                                   Base address register                   Register containing the base address for the load/store operation.
          sdsd                              Source/destination register             Register where values are stored from or loaded to during a load/store operation.
               oooo oooo oooo oooo oooo     Offset (20-bit, +-512kW)                Offset applied to the address in the base address register.


Direct move instructions move values into CPU registers.

3                 1 1                 0
1                 6 5                 0
nnnn nnnn nnnn nnnn nnnn nnnn nnnn nnnn     32-bit word  
b                                           Branch select (implied 0)               Set to zero.
 l                                          Load select (implied 0)                 Set to zero.
  d                                         Direct move select (implied 1)          Flag identifying the instruction as a direct move instruction.
   o                                        Bitwise OR select                       When true, performs a bitwise OR on the contents of the destination register and the value as opposed to replacement.
     dddd                                   Destination register                    Register to store the value into.
          ssss                              Left shift                              Shift for the value to be stored.
               vvvv vvvv vvvv vvvv vvvv     Value (20-bit, +-524288)                Value to store into the destination register.


Arithmetic instructions perform mathematical operations on the contents of CPU registers.

3                 1 1                 0
1                 6 5                 0
nnnn nnnn nnnn nnnn nnnn nnnn nnnn nnnn     32-bit word  
b                                           Branch select (implied 0)               Set to zero.
 l                                          Load select (implied 0)                 Set to zero.
  d                                         Direct move select (implied 0)          Set to zero.
   a                                        Arithmetic select (implied 1)           Flag identifying the instruction as an arithmetic instruction.
     s                                      Second operand select                   When true, uses the value provided as the chosen operation's B term.
      ii                                    Reserved and unused                     Set to zero.
        o oooo                              Operation                               Operation to perform on the provided terms. See below.
               dddd                         Destination register                    Register to store the result of the chosen operation into.
                    aaaa                    Term A register                         Register containing the A term of the operation.
                         bbbb vvvv vvvv     Term B register/Value (8-bit, +-128)    Register containing the B term of the operation, and a value for certain operations.
                         ssss vvvv vvvv     Even left shift/Value (8-bit, +-128)    The B term of the operation, created by shifting the value left by two for as many times specified by the shift.


Register move operations transfer the value of one CPU register to another. They can also exchange the contents of two registers.

3                 1 1                 0
1                 6 5                 0
nnnn nnnn nnnn nnnn nnnn nnnn nnnn nnnn     32-bit word  
b                                           Branch select (implied 0)               Set to zero.
 l                                          Load select (implied 0)                 Set to zero.
  d                                         Direct move select (implied 0)          Set to zero.
   a                                        Arithmetic select (implied 0)           Set to zero.
     r                                      Register select (implied 1)             Flag identifying the instruction as a register move instruction.
      ii                                    Reserved and unused                     Set to zero.
        x                                   Exchange select                         When true, swaps the contents of the two registers.
          dddd                              Destination register                    Register to move the contents of the source register into.
               ssss                         Source register                         Register whose contents are to be moved into the destination register.
                    iiii iiii iiii iiii     Reserved and unused                     Set to zero.


Core instructions control the CPU. They implement things like the no-operation instruction, the software interrupt instruction, and the halt instruction.

3                 1 1                 0
1                 6 5                 0
nnnn nnnn nnnn nnnn nnnn nnnn nnnn nnnn     32-bit word  
b                                           Branch select (implied 0)               Set to zero.
 l                                          Load select (implied 0)                 Set to zero.
  d                                         Direct move select (implied 0)          Set to zero.
   a                                        Arithmetic select (implied 0)           Set to zero.
     r                                      Register select (implied 0)             Set to zero.
      c                                     Core select (implied 1)                 Flag identifying the instruction as a core instruction.
       oo oooo dddd dddd dddd dddd dddd     Operation/Data                          Operation to be performed and its data. See below.
               
                   
Branch instructions expect a three-bit type code that defines the behavior of the branch.
When the most significant bit of the code is zero, the branch behaves normally.
When the most significant bit of the code is one, the branch behaves as a call instruction, either saving or restoring the previous address of execution according to the two least significant bits.
A special case occurs when the MSB is zero, while the LSBs are both one; the branch will then attempt to return from an interrupt using the interrupt control registers and CS register.

b000    Branch                      Branches to the supplied address.
b100    Call, save link             Branches, saving the current location of execution to the link register set by the CS register.
b101    Call, save stack            Branches, saving the current location of execution to the stack.
b110    Call, restore link          Branches to the address stored in the link register set by the CS register.
b111    Call, restore stack         Branches to the address stored on the stack.
b011    Interrupt return            Branches either from the stack or an interrupt link register, performing priority restoration in the process.


Branch instructions expect a four-bit condition code that defines when the branch should be performed.
Condition codes determine their result by querying the carry, zero, negative, and overflow flags of the CS register.
All sixteen possible condition codes are defined. The branch will execute when the chosen condition is true.

h00     Always True                 Always executes.
h01     Equal                       Executes if the zero flag is set.
h02     Not Equal                   Executes if the zero flag is reset.
h03     Higher or Same              Executes if the carry flag is set.
h04     Lower                       Executes if the carry flag is reset.
h05     Negative                    Executes if the negative flag is set.
h06     Positive or Zero            Executes if the negative flag is reset.
h07     Overflow                    Executes if the overflow flag is set.
h08     No Overflow                 Executes if the overflow flag is reset.
h09     Higher                      Executes if the carry flag is set and the zero flag is reset.
h0A     Lower or Same               Executes if the carry flag is reset or if zero flag is set.
h0B     Greater/Equal To            Executes if the negative and overflow flags are equal.
h0C     Less/Equal To               Executes if the negative and overflow flags are inequal.
h0D     Greater Than                Executes if the zero flag is reset and the negative and overflow flags are equal.
h0E     Less Than                   Executes if the zero flag is set or if the negative and zero flags are inequal.
h0F     Always False                Never executes.


Arithmetic instructions expect a five-bit opcode that defines the operation to be performed. 
Most arithmetic operations operate on two terms (A and B); however, some operations work on one term (A) or three terms (A, B, and V).
Only the first sixteen of these operations are currently defined.

h00     Add                         (a + b)
h01     Subtract                    (a - b)
h02     Bitwise AND                 (a & b)
h03     Bitwise OR                  (a | b)
h04     Bitwise XOR                 (a ^ b)
h05     Bitwise NOT                 (~a)
h06     Arithmetic Shift Left       (a << b)
h07     Arithmetic Shift Right      (a >> b)
h08     Logical Shift Right         (a >> b) without sign extension
h09     Rotate Left                 (a r< b)
h0A     Rotate Right                (a r> b)
h0B     Inverse Mask                (a & ~b)
h0C     Mask and Shift Left         ((a & v) << s) or ((a & v) << b)  
h0D     Mask and Shift Right        ((a & v) >> s) or ((a & v) >> b)
h0E     Compare                     (a - b) without result store
h0F     Test                        (a & b) without result store


Core instructions expect a six-bit opcode that defines the operation to be performed, along with a twenty-bit data field.
Only the first four of these operations are currently defined.

h00     No Operation                iiii iiii iiii iiii iiii    Reserved and unused
h01     Software Interrupt          dddd dddd iiii iiii iiii    Interrupt ID (8-bit, +256)/Reserved and unused
h02     Halt                        iiii iiii iiii iiii iiii    Reserved and unused
h03     Set Register Page           pppp hiii iiii iiii iiii    Register Page (4-bit, +16)/Hide Special Registers (1-bit, flag)/Reserved and unused
